# Cycle: e2e-ssrf

| Item | Value |
|------|-------|
| Issue | #26 |
| Phase | DONE |
| Created | 2026-01-07 14:47 |

## Environment

| Tool | Version |
|------|---------|
| Node.js | v22.17.0 |
| Playwright | ^1.40.0 |

## Goal

SSRF脆弱性のE2Eテストを自動生成する。ssrf-attackerの静的解析結果からPlaywrightテストコードを生成し、ローカルコールバックサーバーでSSRF発生を検証。

## Background

Issue #18 (OOBコールバック検証) の代替アプローチ。外部サービス不要、localhost完結。

## Scope

From Issue #26:
- [ ] ssrf-attacker結果からテスト生成
- [ ] ローカルコールバックサーバー統合
- [ ] リクエスト受信検証
- [ ] 外部依存なし（localhost完結）

## PLAN

### Design

```
ssrf-attacker JSON → generate-e2e skill → ssrf.spec.ts
                                        ↓
                              [テスト実行時]
                              ↓
                    localhost:9999 コールバックサーバー起動
                              ↓
                    SSRFペイロード送信
                              ↓
                    コールバック受信確認 → SSRF confirmed
```

### Architecture

| Component | Description |
|-----------|-------------|
| ssrf.spec.ts.tmpl | SSRF専用Playwrightテストテンプレート |
| CallbackServer | テスト内で起動するHTTPサーバー |

### SSRF Test Strategy

| Type | Description | Test Method |
|------|-------------|-------------|
| ssrf | 完全なURL制御 | callback URL送信→受信確認 |
| blind-ssrf | レスポンス非表示 | callback URL送信→受信確認 |
| partial-ssrf | 部分的URL制御 | path含むcallback→受信確認 |

NOTE: 3タイプすべてコールバックサーバー方式で検証可能。

### ssrf-attacker Type Mapping

| ssrf-attacker Type | E2E Test |
|--------------------|----------|
| ssrf | ssrf-callback |
| blind-ssrf | ssrf-callback |
| partial-ssrf | ssrf-callback |

### Files to Create

| File | Description |
|------|-------------|
| plugins/redteam-core/skills/generate-e2e/templates/ssrf.spec.ts.tmpl | SSRFテストテンプレート |

### Template Variables

| Variable | Description | Example |
|----------|-------------|---------|
| {{VULN_ID}} | 脆弱性ID | SSRF-001 |
| {{ENDPOINT}} | テスト対象エンドポイント | /webhook/register |
| {{INPUT_SELECTOR}} | URL入力フィールドセレクタ | #callback_url |
| {{CALLBACK_PORT}} | コールバックサーバーポート | 9999 |
| {{AUTH_ENDPOINT}} | 認証エンドポイント（認証必要時） | /login |
| {{AUTH_EMAIL}} | 認証用メールアドレス | test@example.com |
| {{AUTH_PASSWORD}} | 認証用パスワード | password |

NOTE: AUTH_*変数は認証が必要なSSRFエンドポイント用。環境変数優先パターン（process.env.AUTH_EMAIL）を使用。

### Callback Server Design

```typescript
// テスト内で起動するシンプルなHTTPサーバー
import { createServer, Server, IncomingMessage } from 'http';

interface CallbackServer {
  server: Server;
  port: number;
  receivedPaths: string[];
  close: () => Promise<void>;
}

async function startCallbackServer(port: number): Promise<CallbackServer> {
  const receivedPaths: string[] = [];

  const server = createServer((req: IncomingMessage, res) => {
    receivedPaths.push(req.url || '/');
    res.writeHead(200);
    res.end('OK');
  });

  // 127.0.0.1に明示的バインド（セキュリティ対策）
  await new Promise<void>(resolve => server.listen(port, '127.0.0.1', resolve));

  return {
    server,
    port,
    receivedPaths,
    close: () => new Promise(resolve => server.close(() => resolve())),
  };
}
```

NOTE: beforeAll/afterAllフックでサーバーライフサイクル管理。テストクラッシュ時も確実にクリーンアップ。

### Output Example

```typescript
// ssrf.spec.ts (generated)
import { test, expect } from '@playwright/test';
import { createServer, Server } from 'http';

/**
 * SSRF Security E2E Tests
 * Generated by redteam-skills generate-e2e
 *
 * PURPOSE: PoC (Proof of Concept) verification for SSRF vulnerabilities.
 * These tests PASS when SSRF callback is received (vulnerability EXISTS).
 * Use for security auditing, not regression testing.
 *
 * WARNING: These tests attempt to trigger server-side requests.
 * Only run against authorized targets.
 */

let callbackServer: Server;
let receivedPaths: string[] = [];

test.beforeAll(async () => {
  callbackServer = createServer((req, res) => {
    receivedPaths.push(req.url || '/');
    res.writeHead(200);
    res.end('OK');
  });
  await new Promise<void>(r => callbackServer.listen(9999, '127.0.0.1', r));
});

test.afterAll(async () => {
  await new Promise<void>(r => callbackServer.close(() => r()));
});

test.beforeEach(() => {
  receivedPaths = [];
});

test.describe('SSRF Security Tests', () => {
  test('SSRF-001: SSRF at /webhook/register', async ({ page }) => {
    const callbackUrl = `http://localhost:9999/ssrf-${Date.now()}`;

    // Submit SSRF payload
    await page.goto('/webhook/register');
    await page.fill('#callback_url', callbackUrl);
    await page.click('button[type="submit"]');

    // Wait for callback (3s timeout)
    await page.waitForTimeout(3000);

    // PoC: Verify SSRF occurred (callback received)
    const received = receivedPaths.some(p => p.includes('ssrf-'));
    expect(received).toBe(true);
  });
});
```

### References

- [OWASP SSRF Prevention](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html)
- [CWE-918: Server-Side Request Forgery](https://cwe.mitre.org/data/definitions/918.html)

## Test List

### TODO

### WIP

### DONE
- [x] TC-01: [正常系] ssrf検出結果からテスト生成
- [x] TC-02: [正常系] blind-ssrf検出結果からテスト生成
- [x] TC-03: [正常系] partial-ssrf検出結果からテスト生成
- [x] TC-04: [正常系] コールバックサーバー起動/停止
- [x] TC-05: [境界値] SSRF脆弱性0件時の処理
- [x] TC-06: [エッジケース] 複数SSRF脆弱性
- [x] TC-07: [異常系] コールバックタイムアウト

## REVIEW

### quality-gate Results

| Agent | Score | Status |
|-------|-------|--------|
| Correctness | 42 | PASS |
| Performance | 65 | WARN |
| Security | 35 | PASS |
| Guidelines | 55 | WARN |

**Max Score: 65 (WARN)**

### Accepted Limitations

- waitForTimeout(3000) はPlaywrightアンチパターンだが、SSRFコールバック検出では許容
- 将来の改善: #29 (expect.poll() パターンへの移行)

## Notes

- 依存: #22 e2e-generator-base (完了)
- コールバックサーバー: テスト内で起動/停止
