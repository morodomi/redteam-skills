import { test, expect } from '@playwright/test';

/**
 * CSRF Security E2E Tests
 * Generated by redteam-skills generate-e2e
 *
 * PURPOSE: PoC (Proof of Concept) verification for CSRF vulnerabilities.
 * These tests PASS when CSRF attack succeeds (vulnerability EXISTS).
 * Use for security auditing, not regression testing.
 *
 * WARNING: These tests send attack payloads to the target.
 * Only run against authorized targets.
 */

test.describe('CSRF Security Tests', () => {
  /**
   * CSRF Token Missing Test
   * Sends state-changing request without CSRF token
   * If request succeeds, CSRF protection is missing
   */
  test('{{VULN_ID}}: CSRF token missing at {{ENDPOINT}}', async ({ page, request }) => {
    // Step 1: Authenticate first
    await page.goto('{{AUTH_ENDPOINT}}');
    await page.fill('#email', '{{AUTH_EMAIL}}');
    await page.fill('#password', '{{AUTH_PASSWORD}}');
    await page.click('button[type="submit"]');

    // Wait for authentication to complete
    await page.waitForURL((url) => !url.pathname.includes('login'), { timeout: 10000 });

    // Step 2: Get cookies for authenticated request
    const cookies = await page.context().cookies();
    expect(cookies.length, 'No cookies after login - auth may have failed').toBeGreaterThan(0);
    const cookieHeader = cookies.map(c => `${c.name}=${c.value}`).join('; ');

    // Step 3: Send POST/PUT/DELETE without CSRF token
    const response = await request.post('{{ENDPOINT}}', {
      headers: { 'Cookie': cookieHeader },
      data: { name: 'CSRF Test' },
    });

    // If 200/201, CSRF vulnerability exists (token not required)
    expect(response.status()).toBeLessThan(400);
  });

  /**
   * CSRF Protection Disabled Test
   * Tests endpoints where CSRF protection is explicitly disabled or exempt
   */
  test('{{VULN_ID}}: CSRF protection disabled at {{ENDPOINT}}', async ({ page, request }) => {
    // Authenticate
    await page.goto('{{AUTH_ENDPOINT}}');
    await page.fill('#email', '{{AUTH_EMAIL}}');
    await page.fill('#password', '{{AUTH_PASSWORD}}');
    await page.click('button[type="submit"]');

    // Wait for authentication to complete
    await page.waitForURL((url) => !url.pathname.includes('login'), { timeout: 10000 });

    const cookies = await page.context().cookies();
    expect(cookies.length, 'No cookies after login - auth may have failed').toBeGreaterThan(0);
    const cookieHeader = cookies.map(c => `${c.name}=${c.value}`).join('; ');

    // Send request to exempt/disabled endpoint
    const response = await request.put('{{ENDPOINT}}', {
      headers: { 'Cookie': cookieHeader },
      data: { update: 'test' },
    });

    // Success indicates protection is disabled
    expect(response.status()).toBeLessThan(400);
  });

  /**
   * SameSite Cookie Missing Test
   * Checks if session cookies have proper SameSite attribute
   */
  test('{{VULN_ID}}: SameSite cookie missing at {{ENDPOINT}}', async ({ page }) => {
    // Login to establish session
    await page.goto('{{AUTH_ENDPOINT}}');
    await page.fill('#email', '{{AUTH_EMAIL}}');
    await page.fill('#password', '{{AUTH_PASSWORD}}');
    await page.click('button[type="submit"]');

    // Wait for authentication to complete
    await page.waitForURL((url) => !url.pathname.includes('login'), { timeout: 10000 });

    // Check cookies for SameSite attribute
    const cookies = await page.context().cookies();
    const sessionCookie = cookies.find(c =>
      c.name.toLowerCase().includes('session') ||
      c.name.toLowerCase().includes('auth') ||
      c.name.toLowerCase().includes('sid') ||
      c.name === 'PHPSESSID' ||
      c.name === 'JSESSIONID' ||
      c.name === 'connect.sid'
    );

    // Session cookie must exist for meaningful test
    if (!sessionCookie) {
      throw new Error('Session cookie not found - check cookie naming (session, auth, sid, PHPSESSID, JSESSIONID, connect.sid)');
    }

    // If SameSite is None or not set, vulnerability exists
    const sameSite = sessionCookie.sameSite;
    // sameSite should be 'Strict' or 'Lax' for protection
    // 'None' or undefined indicates vulnerability
    expect(sameSite === 'None' || sameSite === undefined).toBe(true);
  });

  /**
   * Cross-Origin Request Test
   * Simulates attack from malicious site using DELETE method
   *
   * NOTE: This test checks server-side Origin header validation only.
   * Playwright's request API bypasses browser SameSite cookie restrictions.
   * Real cross-origin attacks depend on both server validation AND browser policy.
   */
  test('{{VULN_ID}}: Cross-origin DELETE at {{ENDPOINT}}', async ({ page, request }) => {
    // Authenticate
    await page.goto('{{AUTH_ENDPOINT}}');
    await page.fill('#email', '{{AUTH_EMAIL}}');
    await page.fill('#password', '{{AUTH_PASSWORD}}');
    await page.click('button[type="submit"]');

    // Wait for authentication to complete
    await page.waitForURL((url) => !url.pathname.includes('login'), { timeout: 10000 });

    const cookies = await page.context().cookies();
    expect(cookies.length, 'No cookies after login - auth may have failed').toBeGreaterThan(0);
    const cookieHeader = cookies.map(c => `${c.name}=${c.value}`).join('; ');

    // Send DELETE without CSRF token (simulating cross-origin attack)
    // Tests server-side Origin validation
    const response = await request.delete('{{ENDPOINT}}', {
      headers: {
        'Cookie': cookieHeader,
        'Origin': 'https://attacker.example.com',
      },
    });

    // If successful, server does not validate Origin header
    expect(response.status()).toBeLessThan(400);
  });
});
